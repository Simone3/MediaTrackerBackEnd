import { Document, Model, CollationOptions } from "mongoose";
import { AppError } from "../../models/error/error";

/**
 * Collation search options (for case insensitive ordering)
 */
const COLLATION: CollationOptions = {
	locale: 'en'
};

/**
 * Helper controller that contains util methods for database manipulation
 */
class QueryHelper {

	/**
	 * Helper to get from the database all elements of a model
	 * @param databaseModel the database model
	 * @param conditions optional query conditions
	 * @param sortBy optional sort conditions
	 * @return a promise that will eventually contain the list of all internal model representations of the persisted elements
	 */
	public find<I, D extends Document & I, M extends Model<D>>(databaseModel: M, conditions?: Queryable<I>, sortBy?: Sortable<I>): Promise<I[]> {

		return new Promise((resolve, reject) => {

			databaseModel
				.find(conditions)
				.collation(COLLATION)
				.sort(sortBy)
				.then((documents: D[]) => {

					resolve(documents);
				})
				.catch((error: any) => {

					reject(AppError.DATABASE_FIND.unlessAppError(error));
				});
		});
	}

	/**
	 * Helper to insert a new or updated an existing model to the database
	 * @param internalModel the internal model that works as the data source
	 * @param emptyDocument the empty document that will get all "internalModel" data and will then be saved to the DB
	 * @returns the promise that will eventually return the newly saved element
	 */
	public save<I, D extends Document & I>(internalModel: I, emptyDocument: D): Promise<I> {

		return new Promise((resolve, reject) => {

			// Copy all properties from the internal model to the empty document
			const autogeneratedId =  emptyDocument._id;
			var document = Object.assign(emptyDocument, internalModel);

			// Check if insert or update
			if(document._id) {

				document.isNew = false;
			}
			else {

				document._id = autogeneratedId;
				document.isNew = true;
			}

			document.save((error: any, savedDocument: D) => {
			   
				if(error) {
					
					reject(AppError.DATABASE_SAVE.unlessAppError(error));
				}
				else {

					if(savedDocument) {

						resolve(savedDocument);
					}
					else {

						reject(AppError.DATABASE_SAVE.withDetails('Cannot find document'));
					}
				}
			});
		});
	}

	/**
	 * Helper to delete a database element by ID
	 * @param databaseModel the database model
	 * @param id the element ID
	 * @returns a void promise
	 */
	public deleteById<I, D extends Document & I, M extends Model<D>>(databaseModel: M, id: string): Promise<void> {

		return new Promise((resolve, reject) => {

			databaseModel.findByIdAndRemove(id)
				.then((deletedDocument) => {

					if(deletedDocument) {

						resolve();
					}
					else {

						reject(AppError.DATABASE_DELETE.withDetails('Cannot find document'));
					}
				})
				.catch((error: any) => {

					reject(AppError.DATABASE_DELETE.unlessAppError(error));
				});
		});
	}

	/**
	 * Helper to delete a database elements with a query condition
	 * @param databaseModel the database model
	 * @param conditions query conditions
	 * @returns a promise with the number of deleted elements
	 */
	public delete<I, D extends Document & I, M extends Model<D>>(databaseModel: M, conditions: Queryable<I>): Promise<number> {

		return new Promise((resolve, reject) => {

			databaseModel.deleteMany(conditions)
				.then((deletedDocumentsCount) => {

					resolve(deletedDocumentsCount && deletedDocumentsCount.n ? deletedDocumentsCount.n : 0);
				})
				.catch((error: any) => {

					reject(AppError.DATABASE_DELETE.unlessAppError(error));
				});
		});
	}
}

/**
 * Singleton implementation of the query helper
 */
export const queryHelper = new QueryHelper();

/**
 * Helper type to make all properties in T be optionally asc or desc
 */
export type Sortable<T> = {
    [P in keyof T]?: 'asc' | 'desc';
};

/**
 * Helper type to make all properties in T optional, possibily regular expressions and possibly with nested OR conditions
 */
export type Queryable<T> = {
    [P in keyof T]?: T[P] | RegExp;
} & {$or?: Queryable<T>[]};


