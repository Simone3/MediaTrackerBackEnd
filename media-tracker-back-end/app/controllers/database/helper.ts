import { Document, Model, CollationOptions } from "mongoose";

/**
 * Collation search options (for case insensitive ordering)
 */
const COLLATION: CollationOptions = {
	locale: 'en'
};

/**
 * Abstract helper controller that contains util methods for extending classes
 */
export abstract class AbstractModelController {

	/**
	 * Helper to get from the database all elements of a model
	 * @param databaseModel the database model
	 * @param conditions optional query conditions
	 * @param sortBy optional sort conditions
	 * @return a promise that will eventually contain the list of all internal model representations of the persisted elements
	 */
	protected findHelper<I, D extends Document & I, M extends Model<D>>(databaseModel: M, conditions?: Queryable<I>, sortBy?: Sortable<I>): Promise<I[]> {

		return new Promise((resolve, reject) => {

			databaseModel
				.find(conditions)
				.collation(COLLATION)
				.sort(sortBy)
				.then((documents: D[]) => {

					resolve(documents);
				})
				.catch((error: any) => {

					reject(error);
				});
		});
	}

	/**
	 * Helper to insert a new or updated an existing model to the database
	 * @param internalModel the internal model that works as the data source
	 * @param emptyDocument the empty document that will get all "internalModel" data and will then be saved to the DB
	 * @param notFoundError error to be returned if no element was found
	 * @returns the promise that will eventually return the newly saved element
	 */
	protected saveHelper<I, D extends Document & I>(internalModel: I, emptyDocument: D, notFoundError: string): Promise<I> {

		return new Promise((resolve, reject) => {

			// Copy all properties from the internal model to the empty document
			const autogeneratedId =  emptyDocument._id;
			var document = Object.assign(emptyDocument, internalModel);

			// Check if insert or update
			if(document._id) {

				document.isNew = false;
			}
			else {

				document._id = autogeneratedId;
				document.isNew = true;
			}

			document.save((error: any, savedDocument: D) => {
			   
				if(error) {
					
					reject(error);
				}
				else {

					if(savedDocument) {

						resolve(savedDocument);
					}
					else {

						reject(notFoundError);
					}
				}
			});
		});
	}

	/**
	 * Helper to delete a database element by ID
	 * @param databaseModel the database model
	 * @param id the element ID
	 * @param notFoundError error to be returned if no element was found
	 * @returns a void promise
	 */
	protected deleteByIdHelper<I, D extends Document & I, M extends Model<D>>(databaseModel: M, id: string, notFoundError: string): Promise<void> {

		return new Promise((resolve, reject) => {

			databaseModel.findByIdAndRemove(id)
				.then((deletedDocument) => {

					if(deletedDocument) {

						resolve();
					}
					else {

						reject(notFoundError);
					}
				})
				.catch((error: any) => {

					reject(error);
				});
		});
	}

	/**
	 * Helper to delete a database elements with a query condition
	 * @param databaseModel the database model
	 * @param conditions query conditions
	 * @returns a promise with the number of deleted elements
	 */
	protected deleteHelper<I, D extends Document & I, M extends Model<D>>(databaseModel: M, conditions: Queryable<I>): Promise<number> {

		return new Promise((resolve, reject) => {

			databaseModel.deleteMany(conditions)
				.then((deletedDocumentsCount) => {

					resolve(deletedDocumentsCount && deletedDocumentsCount.n ? deletedDocumentsCount.n : 0);
				})
				.catch((error: any) => {

					reject(error);
				});
		});
	}
}

/**
 * Helper type to make all properties in T be optionally asc or desc
 */
export type Sortable<T> = {
    [P in keyof T]?: 'asc' | 'desc';
};

/**
 * Helper type to make all properties in T optional, possibily regular expressions and possibly with nested OR conditions
 */
export type Queryable<T> = {
    [P in keyof T]?: T[P] | RegExp;
} & {$or?: Queryable<T>[]};


